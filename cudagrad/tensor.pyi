from __future__ import annotations

from typing import Any, List, Tuple, Union

class _DataProxy:
    def __call__(self) -> Any: ...
    def __getitem__(self, index: Union[int, slice]) -> Any: ...
    def __setitem__(self, index: Union[int, slice], value: Any) -> None: ...

class _GradProxy:
    def __call__(self) -> Any: ...
    def __getitem__(self, index: Union[int, slice]) -> Any: ...
    def __setitem__(self, index: Union[int, slice], value: Any) -> None: ...

class Tensor:
    def __init__(self, sizes: List[int], values: List[float]): ...
    def get_shared(self) -> Any: ...
    def backward(self) -> None: ...
    def zero_grad(self) -> None: ...
    def sum(self) -> Tensor: ...
    def relu(self) -> Tensor: ...
    def sigmoid(self) -> Tensor: ...
    @property
    def data(self) -> _DataProxy: ...
    @property
    def grad(self) -> _GradProxy: ...
    def item(self) -> float: ...
    def size(self) -> Tuple[int, ...]: ...
    def graph(self) -> str: ...
    @staticmethod
    def ones(sizes: List[int]) -> Tensor: ...
    @staticmethod
    def zeros(sizes: List[int]) -> Tensor: ...
    @staticmethod
    def explode() -> None: ...
    @staticmethod
    def rand(sizes: List[int]) -> Tensor: ...
    def __eq__(self, other: Tensor) -> Tensor: ... # type: ignore [override]
    def __ne__(self, other: Tensor) -> Tensor: ... # type: ignore [override]
    def __add__(self, other: Tensor) -> Tensor: ...
    def __sub__(self, other: Tensor) -> Tensor: ...
    def __mul__(self, other: Tensor) -> Tensor: ...
    def __truediv__(self, other: Tensor) -> Tensor: ...
    def __matmul__(self, other: Tensor) -> Tensor: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

def hello() -> str: ...
